# Описание проекта K3s с тремя веб-приложениями

Этот проект является продолжением предыдущего задания, где были настроены две виртуальные машины и установлен кластер K3s. Теперь вам необходимо создать машину с мастер нодой для развертывания и настройки трех веб-приложений. Цель — обеспечить доступ к каждому приложению через разные HOST-адреса при обращении по IP **192.168.56.110**.

## Требования

- Используется одна виртуальная машина с IP **192.168.56.110** (например, `nicknameS` из предыдущего задания).
- Vagrant конфигурация используется из предыдущего задания   
- K3s должен быть установлен в режиме сервера.  
- Настройка трех веб-приложений с доступом через разные HOST-адреса:  
  - `app1.com` отображает первое приложение.  
  - `app2.com` отображает второе приложение.  
  - Любой другой запрос по умолчанию отображает третье приложение.  

## Инструкция по выполнению

### Подготовка среды

1. Убедитесь, что K3s установлен и запущен на виртуальной машине:
   ```bash
   curl -sfL https://get.k3s.io | INSTALL_K3S_EXEC="server --flannel-iface eth1" sh -s - --token 12345
   ```
2. Проверьте статус узлов, подключившись по ssh к вирутальной машине:
   ```bash
   sudo kubectl get nodes
   ```

### Развертывание веб-приложений

1. Создайте манифесты для каждого приложения (Deployment и Service). Подробнее с манифестами можно ознакомиться на сайте [kubernetes](https://kubernetes.io/docs/concepts/workloads/controllers/deployment/)
2. Примените их в кластере (в рамках упражнения vagrant конфигурация исполняет скрипт):
   ```bash
   kubectl apply -f app1.yaml
   kubectl apply -f app2.yaml
   kubectl apply -f app3.yaml
   ```

### Настройка маршрутизации

1. Создайте манифест Ingress для маршрутизации запросов в зависимости от HOST.
2. Пример правила для Ingress:
   ```yaml
   apiVersion: networking.k8s.io/v1
   kind: Ingress
   metadata:
     name: app-ingress
   spec:
     rules:
       - host: app1.com
         http:
           paths:
             - path: /
               pathType: Prefix
               backend:
                 service:
                   name: app1-service
                   port:
                     number: 80
       - host: app2.com
         http:
           paths:
             - path: /
               pathType: Prefix
               backend:
                 service:
                   name: app2-service
                   port:
                     number: 80
       - host: app3.com
         http:
           paths:
             - path: /
               pathType: Prefix
               backend:
                 service:
                   name: app3-service
                   port:
                     number: 80
   ```

### Проверка работы

1. Откройте браузер и убедитесь, что приложения доступны по соответствующим адресам.

## Завершение работы

- Остановите кластер K3s, если требуется:
  ```bash
  systemctl stop k3s
  ```
- Очистите кластер:
  ```bash
  kubectl delete all --all
  ```
- Удалить все поды в определённом неймспейсе:
  ```bash
  kubectl delete pods --all -n <namespace>
  ```
- Удалить поды в ноде:
  ```bash
  kubectl delete pod <pod_name>
  ```
- Удалить ноды:
  ```bash
  kubectl delete node <node_name>
  ```

## Немного теории

1. **Deployment (Деплоймент)**

    Роль: Управляет развертыванием и жизненным циклом подов.
    Что делает: Создает и поддерживает заданное количество реплик подов, автоматически обновляет их при изменении образов контейнеров.

Пример:
Если ваш веб-приложение работает в одном контейнере, Deployment создаст и поддержит нужное количество его экземпляров.

2. **Service (Сервис)**

    Роль: Обеспечивает стабильную сеть для взаимодействия подов как внутри, так и за пределами кластера.
    Что делает: Предоставляет постоянный сетевой IP-адрес и DNS-имя для группы подов, на которые можно направлять трафик.

Связь с Deployment:
Service находит поды, которые создал Deployment, по меткам (labels).

В Kubernetes поды являются эфемерными — их IP-адреса динамически назначаются и могут изменяться при перезапуске.
Service предоставляет постоянную точку входа (ClusterIP, NodePort или LoadBalancer), которая связывается с динамическими подами.

Это похоже на то, как Docker Container получает IP, но в Kubernetes Service нужен для стабильности и управления сетевыми запросами.

3. **Ingress (Инресс)**

    Роль: Управляет внешними HTTP/HTTPS-запросами к сервисам внутри кластера.
    Что делает: Позволяет направлять запросы, основанные на хостах и путях, снаружи кластера через сервисы к подам.


**Связь:**
Ingress → Service → Deployment → Pod

Ingress обрабатывает запросы снаружи (например, из браузера).
Запрос перенаправляется к соответствующему Service.
Service направляет трафик на конкретные поды, созданные Deployment.

